<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Binary Search</title>
        <link rel="stylesheet" href="../../../css/main.css" />
        <link rel="stylesheet" href="../../../css/text_styling.css" />
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML" async></script>
        <link href="https://fonts.googleapis.com/css?family=EB+Garamond|Sorts+Mill+Goudy" rel="stylesheet">
    </head>
    <body>
        <header class="page-header">
            <div class="nav-container">
                <h1 class="title">
                    <a href="../../../">Oliver Fleckenstein</a>
                </h1>
                <nav>
                    <a href="../../../about/">About</a>
                </nav>
            </div>
        </header>

        <main role="main" class="main">
            <link rel="stylesheet" href="../../../css/numbering.css" />
<article>
    <section>
        <h1 id="searching-strategies">Searching Strategies</h1>
<p>Searching for elements in a data structure is one of the fundamental problems for every computer scientist and programmer will encounter many times. Given an array <span class="math inline"><em>A</em></span> of integers, consider the problem of determine if a certain number <span class="math inline"><em>x</em></span> apprears in the array or not. Below is an illustration, where the first line is the indexes into the array and the second line is the value at the given index. Consider how to determine if <span class="math inline">41</span> is the array or not.</p>

<p><img src="../../../images/animations/linear_search/integer_array.gif" alt="image" /></p>
<p>A naive approach to this problem is to do a <em>linear search</em>. That is to go through each of the elements one by one, comparing each of the elements if they are equal to <span class="math inline"><em>x</em></span>. Pseudocode for this simple algorithm can be seen here:</p>

<p><img src="../../../images/algorithms/linear_search.png" alt="image" /></p>
<p>It is easy to see that this approach will use linear time, denoted <span class="math inline"><em>O</em>(<em>n</em>)</span> where <span class="math inline"><em>n</em></span> is the number of elements in the array. By analyzing the worst case where the element is last in the array or not in the array at all, we can see that the algorithm will look exactly once at every element in the array. Comparing each element to <span class="math inline"><em>x</em></span> can be done in constant time.</p>
<p>There must be a better way to search through an array. First of all, is there a way we can terminate the algorithm early? Note that the order of the array does not matter in order to determine if an element is in the array or not. Hence, we can <em>sort</em> the array in non-decreasing order, then utilize this fact to know when the element is definitely not in the array.</p>

<p><img src="../../../images/integer_array_sorted.png" alt="image" /></p>
<p>When looking for <span class="math inline">20</span> in the sorted array, it is clear that the element cannot be at any index after <span class="math inline">22</span>, hence we can terminate the algorithm early. However, asymptotically, this will not give a better running time, as the element you are looking for could be larger than any element in the array, causing each element to be analyzed.</p>
<h2 id="a-better-approach---binary-search">A better approach - Binary Search</h2>
<p>Reusing the idea of sorting the array, a better algorithm can be devised using <em>binary search</em> or <em>logarithmic search</em>. Instead of starting from one end of the array, start at the middle of the sorted array and check if the element is equal, smaller, or larger than that element. If it is equal, the algorithm can simple return true, while if the element is smaller, the algorithm can be called recursively on the right part of the array. Similarly, if the element is larger, then the algorithm can run recursively on the left part of the array. This will cut the problem in half in each step!</p>

<p><img src="../../../images/animations/binary_search/integer_array_sorted.gif" alt="image" /></p>
<p>The pseudocode for this algorithm is illustrated here:</p>

<p><img src="../../../images/algorithms/binary_search.png" alt="image" /></p>
<p>Each time the algorithm will cut the problem in half. This means the first iteration will handle a array of size <span class="math inline"><em>n</em></span>, using constant time to compare <span class="math inline"><em>x</em></span> to the middle element. The second iteration will look at half the array, hence a problem of size <span class="math inline"><em>n</em>/2</span>, continuing until the array is empty. Each iteration of the algorithm takes constant time, and in worst case <span class="math inline">⌊lg <em>n</em>⌋</span> iterations is needed. This means the overall running time of the algorithm is <span class="math inline"><em>O</em>(lg <em>n</em>)</span>. This is the fastest known technique to find elements in the general problem membership problem.</p>
    </section>
</article>

        </main>
    </body>
</html>
